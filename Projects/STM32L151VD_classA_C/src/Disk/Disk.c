#include "hw.h"
#include "bsp.h"
#include "fatfs.h"
#include "usb_device.h"

/* MSC Boot Sector Disk Image Definitions for FAT12 (MSDOS5.0) */
// BootSectorImage[19] = 0x10; // for 8192 Byte Disk and 0x08; for 4096 Byte Disk (DiskSize/512)
// BootSectorImage[39..42] = ID -> ID1 could be used
#define MSC_BootSectorSize  512
#if MSC_BlockSize != MSC_BootSectorSize 
  #error "MSC_Blocksize must have same size like the BootSector"
#endif

#ifdef STM32L152xD
  #define MAX_EEPROMSIZE  (12 * 1024) // Cat. 4 device
#else
  #define MAX_EEPROMSIZE  (8 * 1024) // Cat. 3 device
#endif

#if MSC_MemorySize > MAX_EEPROMSIZE
  #ifdef STM32L152xD
    #error "MSC_MemorySize must be <= 12288 (size of the EEPROM)"
  #else
     #error "MSC_MemorySize must be <= 8192 (size of the EEPROM)" 
  #endif
#endif
const uint8_t BootSectorImage[] = {
0xEB,0xFE,0x90,0x4D,0x53,0x44,0x4F,0x53,0x35,0x2E,0x30,0x00,0x02,0x01,0x01,0x00,
0x01,0x10,0x00,0x10,0x00,0xF0,0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x80,0x00,0x29,0x74,0x19,0x02,0x27,0x4C,0x6F,0x52,0x61,0x54,
0x65,0x61,0x73,0x65,0x72,0x20,0x46,0x41,0x54,0x31,0x32,0x20,0x20,0x20,0x00,0x00};
/* Rest of boot sector data will be handled in the programm-code
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0xAA
};
*/

void ZeroDisk(void)
{
  uint32_t ui32Addr;
  
  SetLEDRed(true);  
  HAL_FLASHEx_DATAEEPROM_Unlock();
  for (ui32Addr=MSC_BootSectorSize;ui32Addr<MSC_MemorySize;ui32Addr+=4)
      HAL_FLASHEx_DATAEEPROM_Erase(FLASH_TYPEERASEDATA_WORD, ui32Addr+FLASH_EEPROM_BASE);
         
  HAL_FLASHEx_DATAEEPROM_Lock();
  SetLEDRed(false);  
}

int8_t WriteDisk(const uint8_t *buf, uint32_t blk_addr, uint16_t blk_len)
{
  uint32_t ui32addr = blk_addr * MSC_BlockSize;
  uint32_t ui32EepromAddr;
  uint32_t ui32wordcnt; // ProgrammWord (4 Bytes)
  uint32_t *pui32Buf = (uint32_t*)buf;
    
  
  if (blk_len)
  {
    // BootSector is fixed from Code, so we can use the first 512 Bytes from the EEPROM for somthing else
    if (ui32addr < MSC_BootSectorSize)
    {
      blk_len--;
      ui32addr += MSC_BootSectorSize;
    }
    if (blk_len)
    {
      SetLEDRed(true);  
      HAL_FLASHEx_DATAEEPROM_DisableFixedTimeProgram(); // Only Erase befor Write, when EEPROM_READ != DATA
      // DATA_EEPROM_FixedTimeProgramCmd(ENABLE);
        
      HAL_FLASHEx_DATAEEPROM_Unlock();
      ui32EepromAddr = FLASH_EEPROM_BASE + ui32addr;           
      while (blk_len--)
      {
          for (ui32wordcnt=0;ui32wordcnt<(MSC_BlockSize/4);ui32wordcnt++,ui32EepromAddr+=4,pui32Buf++)
             if (*(uint32_t*)ui32EepromAddr != *pui32Buf)              
               if (HAL_FLASHEx_DATAEEPROM_Program( FLASH_TYPEPROGRAMDATA_WORD, ui32EepromAddr, *pui32Buf) != HAL_OK)
               {
                 //SetLEDRed(true);             
               }
      } 
      HAL_FLASHEx_DATAEEPROM_Lock(); 
      SetLEDRed(false);  
    }
  }
  return 0;
}

int8_t ReadDisk (uint8_t *buf, uint32_t blk_addr, uint16_t blk_len)
{  
  uint32_t ui32addr = blk_addr * MSC_BlockSize;
  
  if (blk_len && (ui32addr < MSC_BootSectorSize))
  {
    // Bootsector
    memset(buf, 0, MSC_BlockSize);
    memcpy(buf, BootSectorImage, sizeof(BootSectorImage));
    buf[19] = MSC_BlockCount;    
    buf[39] = ( ( *( uint32_t* )ID1 ) ) >> 24;
    buf[40] = ( ( *( uint32_t* )ID1 ) ) >> 16;
    buf[41] = ( ( *( uint32_t* )ID1 ) ) >> 8;
    buf[42] = ( ( *( uint32_t* )ID1 ) );        
    buf[MSC_BootSectorSize-2] = 0x55;
    buf[MSC_BootSectorSize-1] = 0xAA;
    ui32addr += MSC_BootSectorSize;
    blk_len -= 1;
  }
  if (blk_len)
    memcpy(buf, (void *)(FLASH_EEPROM_BASE + ui32addr), blk_len * MSC_BlockSize);
  
  return 0;
}
